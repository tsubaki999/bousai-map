<script>
    function createPinMarkerContent() {
        var markerContent = document.createElement('div');
        markerContent.style.cursor = 'pointer'; markerContent.className = 'pin-marker-content';
        var pinContainer = document.createElement('div'); pinContainer.style.cssText = 'position: relative; width: 28px; height: 40px; transform: translate(-50%, -100%);';
        var pinBody = document.createElement('div'); pinBody.style.cssText = 'position: absolute; left: 0; top: 0; width: 28px; height: 28px; border-radius: 50% 50% 50% 0; background: #EA4335; transform: rotate(-45deg); border: 1px solid #C62828;';
        pinContainer.appendChild(pinBody);
        var pinHead = document.createElement('div'); pinHead.style.cssText = 'position: absolute; left: 7px; top: 7px; width: 14px; height: 14px; border-radius: 50%; background: white;';
        pinContainer.appendChild(pinHead);
        markerContent.appendChild(pinContainer);
        return markerContent;
    }

    function placeMonogatariMarkers(stores) {
        if (!stores || stores.length === 0) { console.log("店舗データがありません。"); return; }
        monogatariMarkers.forEach(m => m.marker.setMap(null));
        monogatariMarkers = [];
        stores.forEach(store => {
            const lat = parseFloat(store.lat);
            const lng = parseFloat(store.lng);
            if (!isNaN(lat) && !isNaN(lng)) {
                const position = { lat: lat, lng: lng };
                var marker = new google.maps.marker.AdvancedMarkerElement({ map: map, position: position, content: createPinMarkerContent(), title: store.name });
                monogatariMarkers.push({ marker: marker, name: store.name, address: store.address });
                marker.addListener("gmp-click", () => {
                    var content = `<div style="font-family: sans-serif; font-size: 14px; max-width: 280px;"><strong style="font-size: 16px;">${escapeHtml(store.name)}</strong><br><strong>住所:</strong> ${escapeHtml(store.address)}<br><a href="https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(store.address)}" target="_blank">Googleマップで見る</a></div>`;
                    infoWindow.setContent(content);
                    infoWindow.open({ anchor: marker, map: map });
                });
            } else { console.warn(`無効な座標の店舗データ: ${store.name}`); }
        });
        const initialVisibility = document.getElementById('toggleMonogatariStores').checked;
        const markers = monogatariMarkers.map(m => m.marker);
        toggleLayerVisibility(markers, initialVisibility);
    }
    
    function placeWarningMarkers(warnings) { if (!warnings || warnings.length === 0) { checkStoreImpacts(); return; } warnings.forEach(w => { const lat = parseFloat(w.lat), lng = parseFloat(w.lng); if (isNaN(lat) || isNaN(lng)) return; const style = getWarningStyle(w.title); const circle = new google.maps.Circle({ map: map, center: { lat, lng }, radius: 20000, fillColor: style.color, fillOpacity: 0.25, strokeColor: style.color, strokeOpacity: 0.5, strokeWeight: 1 }); circle.warningStyle = style; allWarningCircles.push(circle); const infoContent = '<strong style="color:' + style.color + ';">' + escapeHtml(w.title) + '</strong><br>' + '<strong>地域:</strong> ' + escapeHtml(w.region) + '<br>' + '<strong>内容:</strong> ' + escapeHtml(w.summary) + '<br>' + '<a href="' + escapeHtml(w.link) + '" target="_blank">詳細(気象庁)</a><br>' + '<strong>発表:</strong> ' + new Date(w.time).toLocaleString(); circle.addListener('click', () => {infoWindow.setContent(infoContent); infoWindow.setPosition({ lat, lng }); infoWindow.open(map);}); }); toggleLayerVisibility(allWarningCircles, document.getElementById('toggleWarnings').checked); checkStoreImpacts(); }
    function createEarthquakeMarkerContent(intensity) { const style = getEarthquakeStyle(intensity); const intensityText = convertIntensityToString(intensity); const container = document.createElement('div'); container.style.position = 'relative'; container.style.width = '40px'; container.style.height = '40px'; const rippleEl = document.createElement('div'); rippleEl.style.cssText = `position: absolute; top: 50%; left: 50%; width: 40px; height: 40px; border-radius: 50%; background-color: ${style.color}; transform: translate(-50%, -50%); animation: ripple 1.5s infinite ease-out;`; const markerEl = document.createElement('div'); markerEl.style.cssText = `position: absolute; top: 50%; left: 50%; display: flex; align-items: center; justify-content: center; width: 40px; height: 40px; border-radius: 50%; background-color: ${style.color}; color: ${style.textColor}; font-size: 14px; font-weight: bold; border: 2px solid #ffffff; box-shadow: 0 2px 4px rgba(0,0,0,0.5); cursor: pointer; transform: translate(-50%, -50%);`; markerEl.textContent = intensityText; container.appendChild(rippleEl); container.appendChild(markerEl); if (!document.getElementById('earthquake-ripple-style')) { const styleSheet = document.createElement("style"); styleSheet.id = 'earthquake-ripple-style'; styleSheet.type = "text/css"; styleSheet.innerText = `@keyframes ripple { 0% { transform: translate(-50%, -50%) scale(0.8); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(2.5); opacity: 0; } }`; document.head.appendChild(styleSheet); } return container; }
    function placeEarthquakeMarkers(quakes) { if (!quakes || quakes.length === 0) return; quakes.forEach(q => { const lat = parseFloat(q.lat), lng = parseFloat(q.lng); if (isNaN(lat) || isNaN(lng)) return; const position = { lat, lng }; const intensity = parseFloat(q.maxIntensity); const style = getEarthquakeStyle(intensity); const circle = new google.maps.Circle({ strokeColor: style.color, strokeOpacity: 0.5, strokeWeight: 1, fillColor: style.color, fillOpacity: 0.2, map: map, center: position, radius: style.scale * 15000, zIndex: 99 }); circle.quakeStyle = style; allEarthquakeCircles.push(circle); const marker = new google.maps.marker.AdvancedMarkerElement({ position, map, content: createEarthquakeMarkerContent(intensity), title: q.title, zIndex: 100 }); allEarthquakeOverlays.push(circle, marker); const infoContent = '<strong>' + escapeHtml(q.title) + '</strong><br>' + '最大震度: ' + convertIntensityToString(intensity) + '<br>' + escapeHtml(q.content) + '<br>' + '<a href="' + escapeHtml(q.detailLink) + '" target="_blank">詳細情報</a>'; marker.addListener('gmp-click', () => { infoWindow.setContent(infoContent); infoWindow.open({ anchor: marker, map: map }); }); circle.addListener('click', () => { infoWindow.setContent(infoContent); infoWindow.setPosition(position); infoWindow.open(map); }); }); toggleLayerVisibility(allEarthquakeOverlays, document.getElementById('toggleEarthquakes').checked); }
    function placeLineShapedPrecipitationPolygons(polygons) { if (!polygons || polygons.length === 0) return; polygons.forEach(area => { const polygonPath = area.coordinates[0].map(coord => ({ lat: coord[1], lng: coord[0] })); const lspPolygon = new google.maps.Polygon({ paths: polygonPath, strokeColor: "#FF00FF", strokeOpacity: 0.8, strokeWeight: 2, fillColor: "#FF00FF", fillOpacity: 0.35, map: map, zIndex: 90 }); allLspPolygons.push(lspPolygon); const infoContent = `<strong style="color:#FF00FF;">【警戒レベル4相当】線状降水帯発生情報</span></strong><br><strong>エリア:</strong> ${escapeHtml(area.name)}<br><strong>発表時刻:</strong> ${new Date(area.time).toLocaleString()}`; lspPolygon.addListener('click', event => { infoWindow.setContent(infoContent); infoWindow.setPosition(event.latLng); infoWindow.open(map); }); }); toggleLayerVisibility(allLspPolygons, document.getElementById('toggleLsp').checked); }
    function placeMerakiOutageMarkers(outages) { if (!outages || outages.length === 0) return; const iconSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><defs><filter id="glow" x="-50%" y="-50%" width="200%" height="200%"><feGaussianBlur stdDeviation="2" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs><circle cx="12" cy="12" r="10" fill="#212121"/><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z" fill="#D32F2F" stroke="#F44336" stroke-width="0.5" style="filter:url(#glow)"/></svg>'; outages.forEach(o => { const lat = parseFloat(o.lat), lng = parseFloat(o.lng); if(isNaN(lat) || isNaN(lng)) return; const markerContent = document.createElement('div'); markerContent.innerHTML = iconSvg; markerContent.style.cursor = 'pointer'; const marker = new google.maps.marker.AdvancedMarkerElement({ map, position: { lat, lng }, content: markerContent, title: o.storeName + ' (スイッチDOWN)' }); allOutageMarkers.push(marker); marker.addListener('gmp-click', () => { const content = `<div style="font-family: sans-serif; font-size: 14px; max-width: 280px;"><strong style="font-size: 16px; color: #D32F2F;">🚨 MerakiスイッチDOWN (停電の可能性)</strong><br><strong>店舗名:</strong> ${escapeHtml(o.storeName)}<br><strong>住所:</strong> ${escapeHtml(o.address)}<br><strong>最終確認時刻:</strong> ${(o.lastSeen ? new Date(o.lastSeen).toLocaleString() : '不明')}<br><small style="color: #757575;">この情報はMerakiネットワーク機器の疎通断を検知したものです。</small></div>`; infoWindow.setContent(content); infoWindow.open({ anchor: marker, map }); }); }); toggleLayerVisibility(allOutageMarkers, document.getElementById('toggleOutages').checked); }
    function placeMarkers() { return new Promise(resolve => { const locationMap = new Map(); if(allRoutes) allRoutes.forEach(route => { if (!locationMap.has(route.origin)) locationMap.set(route.origin, { name: route.originName, type: "base" }); if (route.waypoints) route.waypoints.forEach(w => { if (!locationMap.has(w.address)) locationMap.set(w.address, { name: w.name, type: "store" }); }); if (!locationMap.has(route.destination)) locationMap.set(route.destination, { name: route.destinationName, type: "store" }); }); if (locationMap.size === 0) return resolve(); const geocodingPromises = Array.from(locationMap.entries()).map(([address, info]) => { return new Promise(pResolve => { geocoder.geocode({ address }, (results, status) => { if (status === 'OK' && results[0] && info.type === 'store') { allStoreMarkers.push({ marker: { position: results[0].geometry.location, content: null }, name: info.name, address: address }); } pResolve(); }); }); }); Promise.all(geocodingPromises).then(resolve); }); }   
    function drawFilteredRoutes() { if(!allRoutes) return; renderedRoutes.forEach(r=>r.setMap(null)); animationIntervals.forEach(clearInterval); animationIntervals = []; var filtered = allRoutes.filter(r => (document.getElementById('originSelect').value === "all" || r.originName === document.getElementById('originSelect').value) && (document.getElementById('destinationSelect').value === "all" || r.destinationName === document.getElementById('destinationSelect').value)); filtered.forEach(route => { var waypointsForRequest = (route.waypoints || []).map(w => ({ location: w.address, stopover: true })); directionsService.route({ origin: route.origin, destination: route.destination, waypoints: waypointsForRequest, travelMode: 'DRIVING', drivingOptions: { departureTime: new Date(), trafficModel: 'bestguess' }}, (result, status) => { if (status === 'OK') drawAnimatedRoute(result, route); else console.error('ルート取得失敗:', status, '対象:', route.originName + ' -> ' + route.destinationName); }); }); }
    function drawAnimatedRoute(directionsResult, routeInfo) { var route = directionsResult.routes[0], totalDistance = 0, totalDuration = 0; route.legs.forEach(leg => { totalDistance += leg.distance.value; totalDuration += (leg.duration_in_traffic ? leg.duration_in_traffic.value : leg.duration.value); }); var waypointsDisplay = routeInfo.waypoints && routeInfo.waypoints.length > 0 ? '<strong>経由地:</strong> ' + routeInfo.waypoints.map(wp => escapeHtml(wp.name)).join(' → ') + '<br>' : ''; var tooltipContent = '<div style="font-family: sans-serif; font-size: 14px; max-width: 300px; line-height: 1.6;"><strong style="font-size: 16px; color: #007bff;">ルート詳細</strong><hr style="margin: 4px 0;"><strong>出発地:</strong> ' + escapeHtml(routeInfo.originName) + '<br>' + waypointsDisplay + '<strong>目的地:</strong> ' + escapeHtml(routeInfo.destinationName) + '<hr style="margin: 4px 0;"><strong>総距離:</strong> ' + (totalDistance / 1000).toFixed(1) + ' km<br>' + '<strong>予測所要時間:</strong> ' + Math.round(totalDuration / 60) + ' 分</div>'; var basePolyline = new google.maps.Polyline({ path: route.overview_path, strokeColor: '#0099ff', strokeOpacity: 0.3, strokeWeight: 8, map: map }); var animatedPolyline = new google.maps.Polyline({ path: route.overview_path, strokeOpacity: 0, icons: [{ icon: { path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW, scale: 3, fillColor: '#FF0000', fillOpacity: 0.8, strokeWeight: 1 }, offset: '0%' }], map: map }); basePolyline.addListener('click', e => { infoWindow.setContent(tooltipContent); infoWindow.setPosition(e.latLng); infoWindow.open(map); }); basePolyline.addListener('mouseover', () => { map.getDiv().style.cursor = 'pointer'; }); basePolyline.addListener('mouseout', () => { map.getDiv().style.cursor = ''; }); renderedRoutes.push(basePolyline, animatedPolyline); var count = 0; var interval = setInterval(() => { count = (count + 1) % 200; var icons = animatedPolyline.get('icons'); icons[0].offset = (count / 2) + '%'; animatedPolyline.set('icons', icons); }, 50); animationIntervals.push(interval); }
</script>