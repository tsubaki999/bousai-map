<script>
    // グローバル変数
    var map, directionsService, infoWindow, geocoder, markerClusterer;
    var allRoutes = [], renderedRoutes = [], animationIntervals = [];
    var allOutageMarkers = [], monogatariMarkers = [], affectedStoreOverlays = [];
    var radarUpdateInterval = null;
    var trafficLayer;

    // --- ユーティリティ & UI ---
    function escapeHtml(str) { if (typeof str !== 'string' || !str) return ''; return str.replace(/[&<>"']/g, function(match) { return {'&': '&amp;','<': '&lt;','>': '>', '"': '&quot;',"'": '&#039;'}[match]; }); }
    function togglePanel(header) { var content = header.nextElementSibling; var text = header.innerHTML; if (content.style.maxHeight && content.style.maxHeight !== '0px') { content.style.maxHeight = '0px'; header.innerHTML = text.replace('▴', '▾'); } else { content.style.maxHeight = content.scrollHeight + "px"; header.innerHTML = text.replace('▾', '▴'); } }

    // --- メインロジック ---
    async function initMap() {
        map = new google.maps.Map(document.getElementById("map"), { center: { lat: 36.2048, lng: 138.2529 }, zoom: 5, mapId: 'd9bbe126f7dc436f2b40c092' });
        trafficLayer = new google.maps.TrafficLayer();
        directionsService = new google.maps.DirectionsService();
        infoWindow = new google.maps.InfoWindow();
        geocoder = new google.maps.Geocoder();
        
        setupLayerToggles();
        setupRadarControls();
        
        // ★★★ GeoJSONをサーバーから非同期で取得して地図にロード ★★★
        google.script.run.withSuccessHandler(function(geojson) {
            if (geojson) {
                map.data.addGeoJson(geojson);
            } else {
                console.error("GeoJSONデータの読み込みに失敗しました。");
            }
        }).getGeoJson();

        // データレイヤーのデフォルトスタイルを設定
        map.data.setStyle({
            fillOpacity: 0,
            strokeColor: '#888',
            strokeWeight: 1,
            zIndex: 1
        });
        
        await refreshAllData();
        
        setInterval(() => {
            document.getElementById('loader-overlay').classList.remove('hidden');
            location.reload();
        }, 5 * 60 * 1000);
    }
    
    async function refreshAllData() {
        console.log(`[${new Date().toLocaleTimeString()}] データの更新を開始します...`);
        const loader = document.getElementById('loader-overlay');
        loader.classList.remove('hidden');
        clearAllOverlays();
        
        const [routes, weatherData, affectedStores, monogatariStores, outages] = await Promise.all([
            new Promise(resolve => google.script.run.withSuccessHandler(resolve).getRouteMapData()),
            new Promise(resolve => google.script.run.withSuccessHandler(resolve).getWeatherWarningsFromSheet()),
            new Promise(resolve => google.script.run.withSuccessHandler(resolve).getStoreImpacts()),
            new Promise(resolve => google.script.run.withSuccessHandler(resolve).getMonogatariStores()),
            new Promise(resolve => google.script.run.withSuccessHandler(resolve).getPowerOutageDataFromMeraki())
        ]);
        
        console.log("全データ取得が完了しました。");
        allRoutes = routes;

        populateFilters(routes);
        placeMonogatariMarkers(monogatariStores);
        placeAffectedStoreMarkers(affectedStores);
        updatePrefectureHighlight(weatherData.affectedPrefectures, weatherData.warnings);
        loadWeatherWarnings(weatherData.warnings);
        placeMerakiOutageMarkers(outages);
        
        document.getElementById('last-updated').textContent = '最終更新: ' + new Date().toLocaleTimeString();
        console.log(`[${new Date().toLocaleTimeString()}] データ更新が完了しました。`);
        loader.classList.add('hidden');
    }

    function clearAllOverlays() {
        renderedRoutes.forEach(r => r.setMap(null)); renderedRoutes = [];
        animationIntervals.forEach(clearInterval); animationIntervals = [];
        if (markerClusterer) { markerClusterer.clearMarkers(); }
        affectedStoreOverlays.forEach(o => o.setMap(null)); affectedStoreOverlays = [];
        monogatariMarkers = []; // markerインスタンスはclustererが管理
        allOutageMarkers.forEach(m => m.setMap(null)); allOutageMarkers = [];
        document.getElementById('warningsList').innerHTML = '<li>情報を更新しています...</li>';
        document.getElementById('affectedStoresList').innerHTML = '<li>情報を更新しています...</li>';
    }

    // --- UI/イベント関連 ---
    function setupLayerToggles() {
        document.getElementById('toggleRoutes').addEventListener('change', function(e) { if (e.target.checked) { drawFilteredRoutes(); } else { clearAllRoutes(); } });
        document.getElementById('toggleTraffic').addEventListener('change', (e) => trafficLayer.setMap(e.target.checked ? map : null));
        document.getElementById('toggleOutages').addEventListener('change', (e) => toggleLayerVisibility(allOutageMarkers, e.target.checked));
        document.getElementById('toggleStores').addEventListener('change', (e) => toggleStoreLayer(e.target.checked));
    }
    
    function toggleStoreLayer(isVisible) {
        if (isVisible) {
            if(markerClusterer) markerClusterer.setMap(map);
        } else {
            if(markerClusterer) markerClusterer.setMap(null);
        }
        toggleLayerVisibility(affectedStoreOverlays, isVisible);
    }
    
    function toggleLayerVisibility(overlays, isVisible) { overlays.forEach(overlay => { if(overlay) overlay.setMap(isVisible ? map : null); }); }
    
    function setupRadarControls() { /* ...（変更なし）... */ }
    function populateFilters(data) { /* ...（変更なし）... */ }

    // --- 描画関数 ---
    function createPinMarkerElement() { /* ...（変更なし）... */ }
    function createRiskMarkerElement(color, score) { /* ...（変更なし）... */ }
    function createXSearchButton(address) { /* ...（変更なし）... */ }

    function placeMonogatariMarkers(stores) {
        if (!stores || stores.length === 0) { console.log("店舗データがありません。"); return; }
        if (markerClusterer) { markerClusterer.clearMarkers(); }
        monogatariMarkers = [];
    
        const markers = stores.map(store => {
            const lat = parseFloat(store.lat); const lng = parseFloat(store.lng);
            if (isNaN(lat) || isNaN(lng)) return null;
            const position = { lat, lng };
            const marker = new google.maps.marker.AdvancedMarkerElement({ position, content: createPinMarkerElement(), title: store.name });
            marker.addListener("gmp-click", () => {
                const content = '...'; // infoWindow content
                infoWindow.setContent(content);
                infoWindow.setPosition(position);
                infoWindow.open({map, anchor: marker});
            });
            monogatariMarkers.push({ marker, name: store.name, address: store.address });
            return marker;
        }).filter(m => m !== null);
    
        markerClusterer = new markerClusterer.MarkerClusterer({ markers, map });
        toggleStoreLayer(document.getElementById('toggleStores').checked);
    }

    function placeAffectedStoreMarkers(affectedStores) {
        const list = document.getElementById('affectedStoresList');
        const summaryPanel = document.getElementById('weatherWarnings');
        summaryPanel.querySelector('h3').innerHTML = 'リスクサマリー ▾';
        const summaryList = summaryPanel.querySelector('ul');
        list.innerHTML = '';
        summaryList.innerHTML = '';
        
        const scoreColors = { low: '#f1c40f', medium: '#e67e22', high: '#e74c3c' };

        if (!affectedStores || affectedStores.length === 0) {
            list.innerHTML = '<li>現在、深刻なリスクのある店舗はありません。</li>';
            summaryList.innerHTML = '<li>すべての拠点は平常通りです。</li>';
            return;
        }

        let summaryText = `<strong>${affectedStores.length}件</strong>の店舗でリスクを検知。<br>最高スコアは <strong>${affectedStores[0].score}</strong> (${escapeHtml(affectedStores[0].name)}) です。`;
        summaryList.innerHTML = `<li style="padding: 5px;">${summaryText}</li>`;
        
        affectedStores.forEach(store => { /* ...（変更なし）... */ });
    }
    
    function loadWeatherWarnings(warnings) {
        const summaryPanel = document.getElementById('weatherWarnings');
        summaryPanel.querySelector('h3').innerHTML = 'リスクサマリー ▾'; // Title is changed in placeAffectedStoreMarkers
    }

    function updatePrefectureHighlight(prefectures, warnings) {
        map.data.forEach(feature => { map.data.revertStyle(feature); });
        if (!prefectures || prefectures.length === 0) return;
        map.data.forEach(feature => {
            const prefName = feature.getProperty('name_ja');
            if (prefectures.includes(prefName)) {
                const maxLevelWarning = warnings.filter(w => w.region.startsWith(prefName)).reduce((max, w) => { const style = getWarningStyle(w.title); return style.level > max.level ? style : max; }, { level: 0, color: '#333333' });
                map.data.overrideStyle(feature, { fillColor: maxLevelWarning.color, fillOpacity: 0.4, strokeColor: '#333', strokeWeight: 2, zIndex: 2 });
            }
        });
    }

    function getWarningStyle(title) { if (!title) return { color: '#888888', level: 0, impactLevel: 0, name: '情報' }; if (title.includes('特別警報')) return { color: '#800080', level: 5, impactLevel: 60, name: '特別警報' }; if (title.includes('土砂災害警戒情報') || title.includes('線状降水帯')) return { color: '#FF00FF', level: 4, impactLevel: 40, name: '避難指示相当' }; if (title.includes('警報')) return { color: '#FF0000', level: 3, impactLevel: 20, name: '警報' }; return { impactLevel: 0 }; }
    function placeMerakiOutageMarkers(outages) { /* ...（変更なし）... */ }
    function clearAllRoutes() { /* ...（変更なし）... */ }
    function drawFilteredRoutes() { /* ...（変更なし）... */ }
    function drawAnimatedRoute(directionsResult, routeInfo) { /* ...（変更なし）... */ }
    
    // Google Maps APIの読み込み
    google.script.run.withSuccessHandler(function(apiKey) {
      var clustererScript = document.createElement('script');
      clustererScript.src = 'https://unpkg.com/@googlemaps/markerclusterer/dist/index.min.js';
      clustererScript.async = true;
      clustererScript.onload = function() {
        var mapsScript = document.createElement('script');
        mapsScript.src = 'https://maps.googleapis.com/maps/api/js?key=' + apiKey + '&libraries=marker,geometry,places&callback=initMap';
        mapsScript.async = true;
        document.head.appendChild(mapsScript);
      };
      document.head.appendChild(clustererScript);
    }).getApiKey();
</script>